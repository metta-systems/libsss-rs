use super::frame_type::{FrameType, FrameTypes};
use pnet_macros_support::packet::{Packet, PacketSize};
use pnet_macros_support::types::*;

/*
Figure N: Stream frame layout
```
         ofs :                  sz : description
           0 :                   1 : Frame type (2 - STREAM)
           1 :                   2 : Flags (niuooodf0000000r)
           3 :                   4 : Stream ID
           7 :                   4 : Parent Stream ID (optional, when INIT (i) bit is set)
          11 :                  24 : Stream USID (optional, when USID (u) bit is set)
    11,15,35 : 0,2,3,4,5,6,7,8 (O) : Offset in stream (depending on OFFSET (ooo) bits)
(11,15,35)+O :                   2 : Data length (optional, when DATA LENGTH (d) bit is set) D
(13,17,37)+O :                   D : Data
```

Flags: FIN, INIT, USID, OFFSET, DATA LENGTH, NOACK

 * When `i = INIT, 0x4000` bit is set, this frame initiates the stream by
 *                 providing stream and parent unique IDs.
 * When `u = USID, 0x2000` bit is set, this `INIT` frame includes full stream Unique ID,
 *                 for means of reattachment of pre-existing stream to a channel.
 *                 `USID` bit can only be set when `INIT` bit is set.
 * When `f = FIN, 0x0100` bit is set, this frame marks last transmission on this stream
 *                 in this direction.
 * `ooo = OFFSET` bits encode length of the stream offset field.
 *                 A 0, 16, 24, 32, 40, 48, 56, or 64 bit unsigned number specifying the
 *                 byte offset in the stream for this block of data.
 *                 000 corresponds to 0 bits and 111 corresponds to 64 bits.
 *                 (@todo Should offset be always present?)
 * When `d = DATA LENGTH, 0x0200` bit is set, this frame has a limited number of bytes
 *                 for this stream, provided in length field, otherwise stream data occupies
 *                 the rest of the packet.
 * When `n = NOACK, 0x8000` bit is set, this frame does not require acknowledgement from the
 *                 receiver. Essentialy this frame's data has been removed from waiting-for-ACK
 *                 queue after sending, and so the sender does not care. If there are other frames
 *                 in this packet, they still might require acknowledgement.
 * When `r = RECORD, 0x0001` bit is set, this frame marks end of the record in the stream data.
 *                 Streams support pushing marked records which can then be read as a single entity
 *                 by the receiving side.

If `FIN` bit is set, stream data length may be zero. Otherwise, data length must be non-zero.

Both `INIT` and `FIN` bits may be set at the same time. In this case data length must be non-zero.

Possible combinations of bits:

INIT
INIT,USID
FIN
INIT,FIN
INIT,USID,FIN
*/
#[packet]
pub struct StreamFrame {
    #[construct_with(u8)]
    pub frame_type: FrameType,
    pub no_ack_flag: u1,
    pub init_flag: u1,
    pub usid_flag: u1,
    pub offset_flag: u3,
    pub data_length_flag: u1, // @todo Probably skip this flag and always set data length?
    pub fini_flag: u1,
    pub zeros: u7,
    pub record_flag: u1,
    pub stream_id: u32be,
    #[length = "init_flag * 4"]
    internal_parent_stream_id_field: Vec<u8>,
    #[length = "usid_flag * 24"]
    pub usid: Vec<u8>,
    #[length_fn = "off_fn"]
    internal_offset_field: Vec<u8>,
    #[length = "data_length_flag * 2"]
    internal_data_length_field: Vec<u8>,
    #[payload]
    #[length_fn = "data_length_fn"]
    pub payload: Vec<u8>,
}

fn off_fn<'a>(frame: &StreamFramePacket<'a>) -> usize {
    match frame.get_offset_flag() {
        0 => 0usize,
        x => x as usize + 1usize,
    }
}

fn offset_fn_int<'a>(frame: &StreamFramePacket<'a>) -> Option<usize> {
    let off = off_fn(frame);
    if off == 0 {
        return None;
    }
    let mut v: usize = 0;
    let slice = frame.get_internal_offset_field_raw();
    for i in 0..off {
        v = (v << 8) | slice[i as usize] as usize;
    }
    Some(v)
}

fn data_length_fn_int<'a>(frame: &StreamFramePacket<'a>) -> Option<usize> {
    let off = frame.get_data_length_flag() * 2;
    if off == 0 {
        return None;
    }
    let mut v: usize = 0;
    let slice = frame.get_internal_data_length_field_raw();
    for i in 0..off {
        v = (v << 8) | slice[i as usize] as usize;
    }
    Some(v)
}

fn data_length_fn<'a>(frame: &StreamFramePacket<'a>) -> usize {
    match data_length_fn_int(frame) {
        None => 0usize,
        Some(x) => x,
    }
}

fn parent_stream_id_fn<'a>(frame: &StreamFramePacket<'a>) -> Option<u32> {
    let off = frame.get_init_flag() * 4;
    if off == 0 {
        return None;
    }
    let mut v: u32 = 0;
    let slice = frame.get_internal_parent_stream_id_field_raw();
    for i in 0..off {
        v = (v << 8) | slice[i as usize] as u32;
    }
    Some(v)
}

// These macros don't work because there's no way to concat_idents!() in rust so that the new
// generated name is suitable for declaring and/or calling a fn name. Until rust macros add
// a way to work with composable identifier names, we implement it manually.
//
// macro_rules! varsized_accessor {
//     ($field:ident, $count:expr) => {{
//         let mut v: usize = 0;
//         let slice = self.$field();
//         for i in 0..$count {
//             v = (v << 8) | slice[i] as usize;
//         }
//         Some(v)
//     }};
// }

impl<'a> StreamFramePacket<'a> {
    pub fn get_offset(&self) -> Option<usize> {
        offset_fn_int(self)
    }

    pub fn get_data_length(&self) -> Option<usize> {
        data_length_fn_int(self)
    }

    pub fn get_parent_stream_id(&self) -> Option<u32> {
        parent_stream_id_fn(self)
    }
}

impl<'a> MutableStreamFramePacket<'a> {
    pub fn init_owned(buffer: Vec<u8>, is_datagram: bool) -> Option<Self> {
        let mut packet = Self::owned(buffer)?;
        packet.set_frame_type(FrameTypes::STREAM);
        packet.set_zeros(0);
        packet.set_no_ack_flag(if is_datagram { 1 } else { 0 });
        Some(packet)
    }

    pub fn get_offset(&self) -> Option<usize> {
        offset_fn_int(&self.to_immutable())
    }

    pub fn get_data_length(&self) -> Option<usize> {
        data_length_fn_int(&self.to_immutable())
    }

    pub fn get_parent_stream_id(&self) -> Option<u32> {
        parent_stream_id_fn(&self.to_immutable())
    }

    pub fn set_offset(&mut self, off: usize) {
        match off {
            0 => self.set_offset_flag(0),
            1...0xffff => {
                self.set_offset_flag(1);
                self.set_internal_offset_field(&vec![((off & 0xff00) >> 8) as u8, (off) as u8]);
            }
            0x10000...0xffffff => {
                self.set_offset_flag(2);
                self.set_internal_offset_field(&vec![
                    ((off & 0xff0000) >> 16) as u8,
                    ((off & 0xff00) >> 8) as u8,
                    (off) as u8,
                ]);
            }
            _ => unimplemented!(),
        }
    }

    pub fn set_parent_stream_id(&mut self, parent_stream_id: u32) {
        self.set_init_flag(1);
        self.set_internal_parent_stream_id_field(&vec![
            ((parent_stream_id & 0xff000000) >> 24) as u8,
            ((parent_stream_id & 0xff0000) >> 16) as u8,
            ((parent_stream_id & 0xff00) >> 8) as u8,
            (parent_stream_id) as u8,
        ]);
    }

    pub fn set_data_length(&mut self, length: usize) {
        self.set_data_length_flag(1);
        self.set_internal_data_length_field(&vec![((length & 0xff00) >> 8) as u8, (length) as u8]);
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn assemble_stream_frame_header() {
        let mut packet = MutableStreamFramePacket::init_owned(vec![0; 64], false).unwrap();

        packet.set_fini_flag(1); // manual
        packet.set_usid_flag(1); // set by set_usid(Some(..))
        packet.set_record_flag(0); // manual
        packet.set_stream_id(0x12345678); // manual
        packet.set_parent_stream_id(0x12345676); // manual
        packet.set_usid(b"helloiamusidhelloiamusid"); // manual
        packet.set_offset(0x4321); // manual
        packet.set_data_length(5); // set by set_payload? or manual if we support filling the rest of the packet with data
        packet.set_payload(b"hello");

        assert_eq!(packet.get_internal_offset_field().len(), 2); // Check internal representation length
        assert_eq!(packet.get_offset(), Some(0x4321));
        #[cfg_attr(rustfmt, rustfmt_skip)]
        assert_eq!(
            &packet.packet()[..packet.packet_size()],
            &vec![
                0x02,                    // frame type
                0x67, 0,                 // flags
                0x12, 0x34, 0x56, 0x78,  // stream id
                0x12, 0x34, 0x56, 0x76,  // parent stream id
                104, 101, 108, 108, 111, 105, 97, 109, 117, 115, 105, 100, //usid..
                104, 101, 108, 108, 111, 105, 97, 109, 117, 115, 105, 100, //..usid
                0x43, 0x21,              // offset
                0x00, 0x05,              // payload size
                104, 101, 108, 108, 111, // payload
            ][..]
        );
    }
}
