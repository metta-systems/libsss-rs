use super::frame_type::FrameType;
use pnet_macros_support::types::*;

/*
Figure N: Stream frame layout
```
         ofs :                  sz : description
           0 :                   1 : Frame type (2 - STREAM)
           1 :                   2 : Flags (niuooodf0000000r)
           3 :                   4 : Stream ID
           7 :                   4 : Parent Stream ID (optional, when INIT (i) bit is set)
          11 :                  24 : Stream USID (optional, when USID (u) bit is set)
    11,15,35 : 0,2,3,4,5,6,7,8 (O) : Offset in stream (depending on OFFSET (ooo) bits)
(11,15,35)+O :                   2 : Data length (optional, when DATA LENGTH (d) bit is set) D
(13,17,37)+O :                   D : Data
```

Flags: FIN, INIT, USID, OFFSET, DATA LENGTH, NOACK

 * When `i = INIT, 0x4000` bit is set, this frame initiates the stream by
 *                 providing stream and parent unique IDs.
 * When `u = USID, 0x2000` bit is set, this `INIT` frame includes full stream Unique ID,
 *                 for means of reattachment of pre-existing stream to a channel.
 *                 `USID` bit can only be set when `INIT` bit is set.
 * When `f = FIN, 0x0100` bit is set, this frame marks last transmission on this stream
 *                 in this direction.
 * `ooo = OFFSET` bits encode length of the stream offset field.
 *                 A 0, 16, 24, 32, 40, 48, 56, or 64 bit unsigned number specifying the
 *                 byte offset in the stream for this block of data.
 *                 000 corresponds to 0 bits and 111 corresponds to 64 bits.
 *                 (@todo Should offset be always present?)
 * When `d = DATA LENGTH, 0x0200` bit is set, this frame has a limited number of bytes
 *                 for this stream, provided in length field, otherwise stream data occupies
 *                 the rest of the packet.
 * When `n = NOACK, 0x8000` bit is set, this frame does not require acknowledgement from the
 *                 receiver. Essentialy this frame's data has been removed from waiting-for-ACK
 *                 queue after sending, and so the sender does not care. If there are other frames
 *                 in this packet, they still might require acknowledgement.
 * When `r = RECORD, 0x0001` bit is set, this frame marks end of the record in the stream data.
 *                 Streams support pushing marked records which can then be read as a single entity
 *                 by the receiving side.

If `FIN` bit is set, stream data length may be zero. Otherwise, data length must be non-zero.

Both `INIT` and `FIN` bits may be set at the same time. In this case data length must be non-zero.

Possible combinations of bits:

INIT
INIT,USID
FIN
INIT,FIN
INIT,USID,FIN
*/
#[packet]
pub struct StreamFrame {
    #[construct_with(u8)]
    pub frame_type: FrameType,
    pub no_ack_flag: u1,
    pub init_flag: u1,
    pub usid_flag: u1,
    pub offset_flag: u3,
    pub data_length_flag: u1, // @todo Probably skip this flag and always set data length?
    pub fini_flag: u1,
    pub zeros: u7,
    pub record_flag: u1,
    pub stream_id: u32be,
    #[length = "init_flag * 4"]
    pub parent_stream_id: u32be,
    #[length = "usid_flag * 24"]
    pub usid: Vec<u8>,
    #[length_fn = "off_fn"]
    pub offset: u64be,
    #[length = "data_length_flag * 2"]
    pub data_length: u16be,
    #[payload]
    #[length = "data_length"]
    pub payload: Vec<u8>,
}

fn off_fn<'a>(frame: &StreamFramePacket<'a>) -> usize {
    match frame.get_offset_flag() {
        0 => 0usize,
        x => x as usize + 1usize,
    }
}
